# RUST标准库内存模块代码分析
内存模块的代码路径举例如下(以作者电脑上的路径):  
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\alloc\*.*  
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr\*.*  
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\mem\*.*  
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\intrinsic.rs  
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\alloc.rs  

RUST之所以被认为难学，是因为RUST与C相同，需要对内存做彻底的控制，即程序可以在代码中编写专属内存管理系统，并将内存管理系统与语言类型相关联，将内存块与语言类型做自如的转换。对于除了C之外的高级语言，内存管理是编译器的任务，这就导致对于RUST的内存管理缺乏经验。相对于C，RUST的现代语法特性及内存安全导致RUST的内存块与类型系统的转换不容易被理解。本节将从标准库的内存模块的代码分析中给出RUST内存的本质。理解了RUST内存，RUST语言的最难关便过了。

## RUST类型系统的内存布局 
类型内存布局是指类型的内部变量在内存布局中，内存顺序，内存大小，内存字节对齐等内容。
对于GC机制的高级语言，类型内存布局一般是交由编译器决定的。程序员不需要关心。C/C++语言中类型只有固定的一种内存布局排序方式和一经配置即固定的对齐方式，编译器不会对此进行优化，类型内存布局对程序员是透明的。
RUST则不同，因为泛型，闭包，编译器优化的关系，类型内存布局方式编译器会根据需要对内存布局做调整，对程序员来说复杂类型的内存布局是完全不可预测的，而在内存操作中，类型内存布局的一些信息是必须要使用的，所以，RUST提供了`Layout`内存布局类型。此布局类型结构是类型内存操作的基础。
`Layout`的数据结构如下：
```rust
pub struct Layout {
    // size of the requested block of memory, measured in bytes.
    // 类型需占用的内存大小，用字节数目表示
    size_: usize,
    //  按照此字节数目进行类型内存对齐， NonZeroUsize见代码后面文字分析
    align_: NonZeroUsize,
}
```
*`NonZeroUsize`是一种非0值的usize, 这种类型主要应用于不可取0的值，本结构中， 字节对齐属性变量不能被置0，所以用`NonZeroUsize`来确保安全性。如果用usize类型，那代码中就可能会把0置给align_，导致bug产生。这是RUST的一个设计规则，所有的限制要在类型定义即显性化，从而使bug在编译中就被发现。*

每一个RUST的类型都有自身独特的内存布局Layout。一种类型的Layout可以用`intrinsic::<T>::size_of()`及`intrinsic::<T>::min_align_of()`获得的类型内存大小和对齐来获得。
RUST的内存布局更详细原理阐述请参考[RUST内存布局] (https://doc.rust-lang.org/nomicon/data.html)，

### `#[repr(transparent)]`内存布局模式
repr(transparent)用于仅包含一个成员变量的类型，该类型的内存布局与成员变量类型的内存布局完全一致。类型仅仅具备编译阶段的意义，在运行时，类型变量与其成员变量可以认为是一个相同变量，可以相互无障碍类型转换。使用repr(transparent)布局的类型基本是一种封装结构。

### `#[repr(packed)]`内存布局模式
强制类型成员变量以1字节对齐，此种结构在协议分析和结构化二进制数据文件中经常使用

### `#[repr(RUST)]`内存布局模式
默认的布局方式，采用此种布局，RUST编译器会根据情况来自行优化内存

### `#[repr(C)]`内存布局模式
采用C语言布局方式， 所有结构变量按照声明的顺序在内存排列。默认4字节对齐。

## RUST内存的类型与函数库体系

### intrinsic 固有函数库——内存部分
intrinsics函数由编译器内置实现，并提供给其他模块使用，对于固有函数，没必要去关注如何实现，重要的是了解其功能和如何使用，intrinsics内存函数一般不由库以外的代码直接调用，而是由mem模块和ptr模块封装后再提供给其他模块。 
`intrinsics::drop_in_place<T:Sized?>(to_drop: * mut T)` 在编译器无法自动drop时， 手工调用此函数将内存释放  
`intrinsics::forget<T:Sized?> (_:T)`, 通知编译器不回收forget的变量内存  
`intrinsics::needs_drop<T>()->bool`, 判断T类型是否需要做drop操作，实现了Copy Trait的类型会返回false  
`intrinsics::transmute<T,U>(e:T)->U`, 对于内存布局相同的类型 T和U, 完成将类型T变量转换为类型U变量  
`intrinsics::offset<T>(dst: *const T, offset: usize)->* const T`, 相当于C的类型指针加减计算  
`intrinsics::copy<T>(src:*const T, dst: *mut T, count:usize)`, 内存拷贝， src和dst内存可重叠， 类似c语言中的memmove  
`intrinsics::copy_no_overlapping<T>(src:*const T, dst: * mut T, count:usize)`, 内存拷贝， src和dst内存不重叠  
`intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)` , C语言的memset的RUST实现  
`intrinsics::size_of<T>()->usize` 类型内存空间字节大小  
`intrinsics::min_align_of<T>()->usize` 返回类型对齐字节大小  
`intrinsics::size_of_val<T>(_:*const T)->usize`返回指针指向的变量内存空间字节大小  
`intrinsics::min_align_of_val<T>(_: * const T)->usize` 返回指针指向的变量对齐字节大小  
`intrinsics::volatile_xxxx` 通知编译器不做内存优化的操作函数,一般用于硬件访问  
`intrinsics::volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize)` 内存拷贝  
`intrinsics::volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize)` 功能类似C语言memmove  
`intrinsics::volatile_set_memory<T>(dst: *mut T, val: u8, count: usize)`  功能类似C语言memset  
`intrinsics::volatile_load<T>(src: *const T) -> T`读取内存或寄存器，字节对齐  
`intrinsics::volatile_store<T>(dst: *mut T, val: T)`内存或寄存器写入，字节对齐  
`intrinsics::unaligned_volatile_load<T>(src: *const T) -> T` 字节非对齐  
`intrinsics::unaligned_volatile_store<T>(dst: *mut T, val: T)`字节非对齐  
`intrinsics::raw_eq<T>(a: &T, b: &T) -> bool` 内存比较，类似C语言memcmp  
`pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize` 基于类型T内存布局的偏移量  
`pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否判断, 相等返回ture, 不等返回false  
`pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否不等，不等返回true  

后继章节还会对intrinsic的其他函数做简单分析。intrinsic的详细及全面的内容请参考RUST官方的标准库指南

### ptr模块初探
ptr模块是RUST的对指针的实现模块。
ptr模块主要包含原生指针`*const T/*mut T`, 原生指针封装类型`NonNull<T>/Unique<T>`, 本节主要集中在原生指针的类型结构及少量方法，为后继的mem模块分析做准备。
RUST原生指针不象C那样仅仅是一个地址值，为满足实现内存安全的类型系统需求，并兼顾内存使用效率和方便性，RUST的指针实质是一个不太容易理解的类型结构。

#### ptr模块中原生指针具体实现
RUST的原生指针类型(`*const T/*mut T`)实质是个数据结构体，由两个部分组成，第一个部分是一个内存地址，第二个部分对这个内存地址的限制性描述-元数据
```rust
//从下面结构定义可以看到，*const T本质就是PtrComponents<T>
pub(crate) union PtrRepr<T: ?Sized> {
    pub(crate) const_ptr: *const T,
    pub(crate) mut_ptr: *mut T,
    pub(crate) components: PtrComponents<T>,
}

pub(crate) struct PtrComponents<T: ?Sized> {
    //只能用*const (), * const T编译器已经默认还带有元数据。
    pub(crate) data_address: *const (),
    //不同类型指针的元数据
    pub(crate) metadata: <T as Pointee>::Metadata,
}

//从下面Pointee的定义可以看到一个RUST的编程技巧，即Trait可以只用来实现对关联类型的指定，Pointee这一Trait即只用来指定Metadata的类型。
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}
//廋指针元数据是单元类型，即是空
pub trait Thin = Pointee<Metadata = ()>;
```
元数据的规则:
* 对于固定大小类型的指针（实现了 `Sized` Trait）, RUST定义为廋指针(thin pointer)，元数据大小为0，类型为(),这里要注意，RUST中数组也是固定大小的类型，运行中对数组下标合法性的检测，就是比较是否已经越过了数组的内存大小。
* 对于动态大小类型的指针(DST 类型)，RUST定义为胖指针(fat pointer 或 wide pointer), 元数据为：  
    * 对于结构类型，如果最后一个成员是动态大小类型(结构的其他成员不允许为动态大小类型)，则元数据为此动态大小类型  
    的元数据  
    * 对于`str`类型, 元数据是按字节计算的长度值，元数据类型是usize  
    * 对于切片类型，例如`[T]`类型，元数据是数组元素的数目值，元数据类型是usize   
    * 对于trait对象，例如 dyn SomeTrait， 元数据是 [DynMetadata<Self>][DynMetadata]（后面代码解释）
    （例如：DynMetadata<dyn SomeTrait>)
随着RUST的发展，有可能会根据需要引入新的元数据种类。

在标准库代码当中没有指针类型如何实现Pointee Trait的代码，编译器针对每个类型自动的实现了Pointee。
如下为rust编译器代码的一个摘录
```rust
    pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
        // FIXME: should this normalize?
        let tail = tcx.struct_tail_without_normalization(self);
        match tail.kind() {
            // Sized types
            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
            | ty::Uint(_)
            | ty::Int(_)
            | ty::Bool
            | ty::Float(_)
            | ty::FnDef(..)
            | ty::FnPtr(_)
            | ty::RawPtr(..)
            | ty::Char
            | ty::Ref(..)
            | ty::Generator(..)
            | ty::GeneratorWitness(..)
            | ty::Array(..)
            | ty::Closure(..)
            | ty::Never
            | ty::Error(_)
            | ty::Foreign(..)
            | ty::Adt(..)
            // 如果是固定类型，元数据是单元类型 tcx.types.unit，即为空
            | ty::Tuple(..) => tcx.types.unit,

            //对于字符串和切片类型，元数据为长度tcx.types.usize，是元素长度
            ty::Str | ty::Slice(_) => tcx.types.usize,

            //对于dyn Trait类型， 元数据从具体的DynMetadata获取*
            ty::Dynamic(..) => {
                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
                tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])
            },
            
            //以下类型不应有元数据
            ty::Projection(_)
            | ty::Param(_)
            | ty::Opaque(..)
            | ty::Infer(ty::TyVar(_))
            | ty::Bound(..)
            | ty::Placeholder(..)
            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
                bug!("`ptr_metadata_ty` applied to unexpected type: {:?}", tail)
            }
        }
    }
```
以上代码中的中文注释比较清晰的说明了编译器对每一个类型（或类型指针）都实现了Pointee中元数据类型的获取。
对于Trait对象的元数据的具体结构定义见如下代码：
```rust
//dyn Trait的元数据结构
pub struct DynMetadata<Dyn: ?Sized> {
    //堆中的函数VTTable变量的指针
    vtable_ptr: &'static VTable,
    //标示结构对Dyn的所有权关系
    phantom: crate::marker::PhantomData<Dyn>,
}

struct VTable {
    //指向实现Trait的类型结构体的drop_in_place函数的指针
    drop_in_place: fn(*mut ()),
    //指向实现Trait的类型结构体的大小
    size_of: usize,
    //指向实现Trait的类型结构体字节对齐
    align_of: usize,
    //后继是结构体实现Trait的所有方法的指针数组
}
```
`PhantomData`的含义英文如下：
 Zero-sized type used to mark things that "act like" they own a `T`.
一个零占用的变量，使得结构逻辑上拥有了一个T类型的变量的所有权，编译器即可用PhantomData判断类型结构体的一些代码安全问题。

#### ptr模块函数
`ptr::drop_in_place<T: ?Sized>(to_drop: *mut T)` 此函数是编译器实现的，用于不需要RUST自动drop时，由程序代码调用以释放内存  
`ptr::metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata `用来返回原生指针的元数据  
`ptr::null<T>() -> *const T` 返回0值的`*const T`，因为RUST安全代码中指针不可能为0，所以只能用这个函数获得0值的* const T，这个函数也是RUST安全性的一个体现。需要说明，此时* const T仅具有数值意义。 
`ptr::null_mut<T>()->*mut T` 同上，只是返回的是`*mut T`  
`ptr::from_raw_parts<T: ?Sized>(data_address: *const (), metadata: <T as Pointee>::Metadata) -> *const T` 从内存地址和元数据生成原生指针  
`ptr::from_raw_parts_mut<T: ?Sized>(data_address: *mut (), metadata: <T as Pointee>::Metadata) -> *mut T` 功能同上，形成可变指针  
RUST指针类型转换时，经常使用以上两个函数获得需要的指针类型。

`ptr::slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] `  
`ptr::slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T]` 由原生指针类型及切片长度获得原生切片类型指针  
代码如下：
```rust
pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {
    //data.cast()将*const T转换为 *const()
    from_raw_parts(data.cast(), len)
}

pub const fn from_raw_parts<T: ?Sized>(
    data_address: *const (),
    metadata: <T as Pointee>::Metadata,
) -> *const T {
    //由以下代码可以确认 * const T实质就是PtrRepr类型结构体。
    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }
}
```
ptr模块的函数大部分逻辑都比较简单。很多就是对intrinsic 函数做调用。

`*const T/* mut T`被使用的场景如下：
1.需要做内存布局相同的两个类型之间的转换，
2.对于数组或切片做头指针偏移以获取元素变量
3.由内存头指针生成数组或切片指针 
4.内存拷贝或内存读出/写入
以上4个场景实际上都是底层编程中最基础的操作。

#### `*const T/*mut T/*const [T]/*mut [T]` 若干方法
`ptr::*const T::is_null(self)->bool`  
`ptr::*mut T::is_null(self)->bool此`函数判断原生指针的地址值是否为0  
`ptr::*const T::cast<U>(self) -> *const U ` ，本质上就是一个`*const T as *const U`。  
`ptr::*mut T::cast<U>(self)->*mut U` 连同上行，cast函数主要完成不同类型的原生指针的互相转换，要注意，如果后继要把返回的指针转换成引用，那必须保证T类型与U类型内存布局完全一致。如果仅仅是将返回值做数值应用，则此限制可以不遵守。  
`ptr::*const T::to_raw_parts(self) -> (*const (), <T as super::Pointee>::Metadata)`   
`ptr::*mut T::to_raw_parts(self)->(* const (), <T as super::Pointee>::Metadata)`  由原生指针获得地址及元数据  
```ptr::*const T::as_ref<`a>(self) -> Option<&`a T>``` 将原生指针转换为引用，因为*const T可能为零，所有需要转换为``Option<& `a T>``类型，转换的安全性由程序员保证，尤其注意满足RUST对引用的安全要求。转换后，数据进入安全的RUST环境。  
```ptr::*mut T::as_ref<`a>(self)->Option<&`a T>```   同上
```ptr::*mut T::as_mut<`a>(self)->Option<&`a mut T>```同上，但转化类型为 &mut T。  
`ptr::*const T::offset(self, count:isize)->* const T` `*mut T::offset(self, count:isize)->* mut T` 实质是intrinsics::offset的封装  
`ptr::*const [T]::len()->usize` 获取切片元素数量  
`*const T`及`*mut T`的方法的逻辑基本也都比较简单，难点在于涉及到较多的指针类型转换，有时需要细致分析，举例如下：
```rust
    //该方法用于仅给指针的 address部分赋值  
    pub fn set_ptr_value(mut self, val: *const u8) -> Self {
        // 这个类型变换几乎是指针变换最多的代码
        // 将self转换为一个瘦指针， self原先可能是一个胖指针
        let thin = &mut self as *mut *const T as *mut *const u8;
        // 这个赋值仅仅做了address的赋值，对于瘦指针，这个相当于赋值操作，
        // 对于胖指针，则没有改变胖指针的元数据。这种操作方式仅仅在极少数的情况下
        // 可以使用，极度危险。
        unsafe { *thin = val };
        self
    }
```

#### RUST引用`&T`的安全要求
1. 引用的内存地址必须是内存2的幂次字节对齐的
2. 引用的内存内容必须是初始化过的
举例：
 ```rust
    #[repr(packed)]
    struct RefTest {a:u8, b:u16, c:u32}
    fn main() {
        let test = RefTest{a:1, b:2, c:3};
        //下面代码无法通过编译，因为test.b 内存字节位于奇数，无法用于借用
        let ref1 = &test.b
    }
 ```

#### NonNull
定义如下：
```rust
#[repr(transparent)]
pub struct NonNull<T: ?Sized> {
    pointer: *const T,
}
```
如前文，因为`NonNull<T>`是`repr(transparent)`内存布局模式，所以，`NonNull<T>`在内存中与`*const T`完全一致。可以直接转化为`* const T`。
RUST常用的这种封装类型。因为`* const T`是没有所有权，借用，生命周期这些属性的，完全脱离了RUST编译器的管理。但用NonNull<T>封装后，NonNull作为一个类型变量，自身具备了所有权，借用，生命周期这些属性, RUST编译器就可以对其管理了。此时要注意区别NonNull变量自身具有的所有权与NonNull拥有内部变量pointer指向的`*const T`的所有权的区别。NonNull不拥有`*const T`的所有权
另外，NonNull<T>确保指针是非零值。指针为0实际上代表指针异常，在RUST中，这种情况应该用Option::None来表示。有了NonNull<T>后，即可以用Option<NonNull<T>>来处理指针为0的情况。

NonNull<T>的相关方法： 
```NonNull::<T>::cast<U>(self)->NonNull<U>``` 指针类型转换，程序员应该保证T和U的内存布局相同 
```rust 
    pub const fn cast<U>(self) -> NonNull<U> {
        //用内部变量指针类型转换完成转换
        unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }
    }
```
```NonNull::<T>::new(* mut T)->Option<Self>``` 可以判断`* mut T`是否为0值，并返回`Option<NonNull<T>>`类型,  
```rust
    pub fn new(ptr: *mut T) -> Option<Self> {
        if !ptr.is_null() {
            Some(unsafe { Self::new_unchecked(ptr) })
        } else {
            None
        }
    }
```
```NonNull::<T>::new_unchecked(* mut T)->Self``` 封装`* mut T`，不检查`* mut T`是否为0，调用者应保证`* mu T`不为0  
```rust
    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {
        unsafe { NonNull { pointer: ptr as _ } }
    }
```
```NonNull::<T>::from_raw_parts( data_address: NonNull<()>, metadata: <T as super::Pointee>::Metadata) -> NonNull<T> ```，实际上先调用`ptr::from_raw_parts`形成`* const T`的指针，然后再形成`NonNull<T>`。  
```rust
    pub const fn from_raw_parts(
        data_address: NonNull<()>,
        metadata: <T as super::Pointee>::Metadata,
    ) -> NonNull<T> {
        // 会调用 `ptr::from_raw_parts_mut`.
        unsafe {
            NonNull::new_unchecked(super::from_raw_parts_mut(data_address.as_ptr(), metadata))
        }
    }
```
`NonNull::<T>::to_raw_parts(self) -> (NonNull<()>, <T as super::Pointee>::Metadata)` 上面函数的反操作  
`NonNull::<T>::as_ptr(self)->* mut T` 返回原生指针  
```rust
    pub const fn as_ptr(self) -> *mut T {
        self.pointer as *mut T
    }
```
```NonNull::<T>::as_ref<`a>(&self)->&`a T ``` 
```rust
    pub unsafe fn as_ref<'a>(&self) -> &'a T {
        // 常用的代码
        unsafe { &*self.as_ptr() }
    }
``` 
```NonNull::<T>::as_mut<`a>(&mut self)->&`a mut T``` 从NonNull返回结构引用，此时程序员应保证符合引用安全的规则  
```NonNull::<[T]>::slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self``` 将类型指针转化为类型的切片类型指针，实质是`ptr::slice_from_raw_parts`的一种包装。  
以下的实例展示了 NonNull在动态申请堆内存的使用：
```rust
    impl Global {
        fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
            match layout.size() {
                0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
                // SAFETY: `layout` is non-zero in size,
                size => unsafe {
                    //raw_ptr是 *const u8类型
                    let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
                    //NonNull::new处理了raw_ptr为零的情况,返回NonNull<u8>,此时内存长度还与T不匹配
                    let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                    //将NonNull<u8>转换为NonNull<[u8]>, NonNull<[u8]>已经是类型T的内存长度。后继可以直接转换为T类型的指针了。
                    Ok(NonNull::slice_from_raw_parts(ptr, size))
                },
            }
        }
        ....
    }
```

### mem模块结构及函数

#### MaybeUninit<T>

##### MaybeUninit<T>结构定义
源代码如下：
```rust
    #[repr(transparent)] 
    pub union MaybeUninit<T> {
        uninit: (),
        value: ManuallyDrop<T>,
    }
```
MaybeUninit的内存布局就是`ManuallyDrop<T>`的内存布局，从后文可以看到，`ManuallyDrop<T>`实际就是T的内存布局。所以MaybeUninit在内存中实质也就是T类型。
RUST的引用使用的内存块必须保证是内存对齐及赋以初始值，未初始化的内存块和清零的内存块都不能满足引用的条件。但堆内存申请后都是未初始化的，且在程序中某些情况下也需要先将内存设置为未初始化，尤其在处理泛型时。因此，RUST提供了MaybeUninit<T>容器来实现对未初始化变量的封装，以便在不引发编译错误完成对T类型未初始化变量的相关操作.
MaybeUninit<T>利用ManuallyDrop<T>的方式对T的未初始化进行了一个标识。这对T也有一个保护，使得未初始化的变量免于被RUST自动调用drop所释放掉.

##### ManuallyDrop<T> 结构及方法
源代码如下：
```rust
#[repr(transparent)]
pub struct ManuallyDrop<T: ?Sized> {
    value: T,
}
```
一个变量被ManuallyDrop获取所有权后，RUST编译器将不再对其自动调用drop操作。需要代码显式的调用drop来释放置入ManuallyDrop的T类型变量。
ManuallyDrop主要使用场景：
1. 作为MaybeUninit的内部结构，对未初始化的内存做一个保护和标识。
2. 希望由代码显式释放变量时。

重点关注的一些方法： 
`ManuallyDrop<T>::new（val:T) -> ManuallyDrop<T>`, 此函数返回ManuallyDrop变量拥有传入的T类型变量所有权，并将此块内存直接用ManuallyDrop封装, 对于val，编译器不再主动做drop操作。 
```rust
    pub const fn new(value: T) -> ManuallyDrop<T> {
        //所有权转移到结构体内部，编译器将忽略这个所有权
        ManuallyDrop { value }
    }
```  
`ManuallyDrop<T>::into_inner(slot: ManuallyDrop<T>)->T`, 将封装的T类型变量所有权转移出来，编译器会重新将返回的变量纳入drop管理体系。  
```rust
    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {
        //将value解封装，所有权转移到返回值中，编译器重新对所有权做处理
        slot.value
    }
```
`ManuallyDrop<T>::take(slot: &mut ManuallyDrop<T>)->T`，实质是复制一个变量，原变量仍然保留在ManuallyDrop中，但所有权已经转移到复制的变量中，后继不能再调用take或into_inner函数，否则可能会导致悬垂指针的问题。  
```rust
    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {
        // 拷贝内部变量，并返回内部变量的所有权
        unsafe { ptr::read(&slot.value) }
    }
```
`ManuallyDrop<T>::drop(slot: &mut ManuallyDrop<T>)`，手动drop掉内部变量。  
`ManuallyDrop<T>::deref(&self)-> & T`, 返回内部包装的变量的引用 
```rust
    fn deref(&self) -> &T {
        //返回后，代码可以用&T对self.value做改动
        &self.value
    }
```
`ManuallyDrop<T>::deref_mut(&mut self)-> & mut T`返回内部包装的变量的可变引用，返回的引用可正常使用  

ManuallyDrop代码举例：
```rust
    use std::mem::ManuallyDrop;
    let mut x = ManuallyDrop::new(String::from("Hello World!"));
    x.truncate(5); // 此时会调用deref
    assert_eq!(*x, "Hello");
    // 但对x的drop不会再发生
```

##### MaybeUninit<T> 方法
MaybeUninit<T>提供了在GlobalAlloc Trait之外的一种获取内存的方法， 实际上可类比为泛型 new()的一种实现方式,不过返回的不是指针，而是变量。MaybeUninit<T>获取的内存位于栈空间。 
`MaybeUninit<T>::uninit()->MaybeUninit<T>`, 是MaybeUninit<T>栈上申请内存的方法，申请的内存大小是T类型的内存大小，该内存没有初始化。利用泛型和Union内存布局，RUST巧妙的实现了在栈上申请一块未初始化内存。此函数非常非常非常值得关注，是非常多场景下的代码解决方案。
```rust
    pub const fn uninit() -> MaybeUninit<T> {
        //变量内存布局与T类型完全一致
        MaybeUninit { uninit: () }
    }
```
`MaybeUninit<T>::new(val:T)->MaybeUninit<T>`, 内部用ManuallyDrop封装了val, 然后用MaybeUninit封装ManuallyDrop。因为如果T没有初始化过，调用这个函数会编译失败，所以此时内存实际上已经初始化过了。 
```rust
    pub const fn new(val: T) -> MaybeUninit<T> {
        //val这个时候是初始化过的。
        MaybeUninit { value: ManuallyDrop::new(val) }
    }
```
`MaybeUninit<T>::zeroed()->MaybeUninit<T>`, 申请了T类型内存并清零。 
```rust
    pub fn zeroed() -> MaybeUninit<T> {
        let mut u = MaybeUninit::<T>::uninit();
        // SAFETY: `u.as_mut_ptr()` points to allocated memory.
        unsafe {
            //必须使用write_bytes，否则无法给内存清0
            u.as_mut_ptr().write_bytes(0u8, 1);
        }
        u
    }
```
`MaybeUninit<T>::assume_init()->T`,代码如下：

```rust
    pub const unsafe fn assume_init(self) -> T {
        // 调用者必须保证self已经初始化了
        unsafe {
            intrinsics::assert_inhabited::<T>();
            //把T的所有权返回，编译器会主动对T调用drop
            ManuallyDrop::into_inner(self.value)
        }
    }
```
`MaybeUninit<T>::assume_init_read()->T` 此函数最后会调用ptr::read()函数。代码如下：
```rust
    pub const unsafe fn assume_init_read(&self) -> T {
        
        unsafe {
            intrinsics::assert_inhabited::<T>();
            //会调用ptr::read
            self.as_ptr().read()
        }
    }

    //此函即ptr::read, 会复制一个变量，此时注意，实际上src指向的变量的所有权已经转移给了返回变量，
    //所以调用此函数的前提是src的所有权必须有后继处理，例如src本身处于ManallyDrop，或src后继调用forget，
    //或给src赋以新的所有权。
    //但在assume_init_read()中使用此函数不会导致问题，因为src被ManuallyDrop封装，不会被释放。
    pub const unsafe fn read<T>(src: *const T) -> T {` 
        //利用MaybeUninit::uninit申请未初始化的T类型内存
        let mut tmp = MaybeUninit::<T>::uninit();
        unsafe {
            //完成内存拷贝
            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);
            //初始化后的内存移出ManuallyDrop 并返回
            tmp.assume_init()
        }
    }
```
可见，assume_init_read 方法实际上是从一个已有类型生成并复制一个新的变量。MaybeUninit的变量后继不能再调用assume_init，可能会导致重复drop。 
`MaybeUninit<T>::assume_init_drop()` 对内部变量进行drop操作  
`MaybeUninit<T>::assume_init_ref()->&T` 返回内部T类型变量的借用，调用者应保证内部T类型变量已经初始化，&T此时是完全正常的  
`MaybeUninit<T>::assume_init_mut()->&mut T`返回内部T类型变量的可变借用，调用者应保证内部T类型变量已经初始化，&mut T此时是完全正常的  
`MaybeUninit<T>::write(val)->&mut T`, 代码如下： 
```rust
    pub const fn write(&mut self, val: T) -> &mut T {
        //通常情况下，如果*self是初始化过得，那调用下面的等式时，会立刻调用*self拥有所有权变量的drop。但因为MaybeUninit<T>封装的变量不会被drop。所以下面这个等式实际上隐含了 *self必须是未初始化的，否则的话，这里会丢失掉已初始化的变量所有权信息，可能造成内存泄漏。
        *self = MaybeUninit::new(val);
        // SAFETY: We just initialized this value.
        unsafe { self.assume_init_mut() }
    }
```
`MaybeUninit<T>::uninit_array<const LEN:usize>()->[Self; LEN]` 此处对LEN的使用方式需要注意，这是不常见的一个泛型写法,这个函数同样的申请了一块内存。代码： 
```rust
    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {
        // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.
        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }
    }
```
这里要注意区别数组类型和数组元素的初始化。对于数组[MaybeUninit<T>;LEN]这一类型本身来说，初始化就是确定整体的内存大小，所以数组类型在声明后就已经完成了。所以此时assume_init()是正确的。这是一个理解上的盲点。 

`MaybeUninit<T>::array_assume_init<const N:usize>(array: [Self; N]) -> [T; N]` 这个函数没有把所有权转移出来，代码分析如下：
```rust
    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {
        // SAFETY:
        // * The caller guarantees that all elements of the array are initialized
        // * `MaybeUninit<T>` and T are guaranteed to have the same layout
        // * `MaybeUninit` does not drop, so there are no double-frees
        // And thus the conversion is safe
        unsafe {
            //最后是调用是*const T::read()，此处 as *const _的写法可以简化代码,这里没有把T类型变量所有权转移到返回值
            //返回后，此MaybeUninit变量应该被丢弃
            (&array as *const _ as *const [T; N]).read()
        }
    }
```
MaybeUninit<T>一些典型使用代码例子：

```rust
    use std::mem::MaybeUninit;

    // Create an explicitly uninitialized reference. The compiler knows that data inside
    // a `MaybeUninit<T>` may be invalid, and hence this is not UB:
    // 获得一个未初始化的i32引用类型内存
    let mut x = MaybeUninit::<&i32>::uninit();
    // Set it to a valid value.
    // 将&0写入变量，完成初始化
    x.write(&0);
    // Extract the initialized data -- this is only allowed *after* properly
    // initializing `x`!
    // 将初始化后的变量解封装供后继的代码使用。
    let x = unsafe { x.assume_init() };
```
以上代码，编译器不会对x.write进行报警，这是MaybeUninit<T>的最重要的应用，这个例子展示了RUST如何给未初始化内存赋值的处理方式。调用assume_init前，必须保证变量已经被正确初始化。

更复杂的例子：
```rust
    use std::mem::{self, MaybeUninit};
    
    let data = {
    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is
    // safe because the type we are claiming to have initialized here is a
    // bunch of `MaybeUninit`s, which do not require initialization.
    // data在声明后实际上就已经初始化完毕。
    let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {
        //这里注意实际调用是MaybeUninit::<[MaybeUninit<Vec<u32>>;1000]>::uninit(), RUST的类型推断机制完成了泛型实例化
        MaybeUninit::uninit().assume_init()
    };
    
    // Dropping a `MaybeUninit` does nothing. Thus using raw pointer
    // assignment instead of `ptr::write` does not cause the old
    // uninitialized value to be dropped. Also if there is a panic during
    // this loop, we have a memory leak, but there is no memory safety
    // issue.
    for elem in &mut data[..] {
    elem.write(vec![42]);
    }
    
    // Everything is initialized. Transmute the array to the
    // initialized type.
    // 直接用transmute完成整个数组类型的转换
    unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }
    };
    
    assert_eq!(&data[0], &[42]);
```
下面例子说明一块内存被 MaybeUnint<T>封装后，编译器将不再对其做释放，必须在代码中显式释放：
```rust
    use std::mem::MaybeUninit;
    use std::ptr;
   
    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is
    // safe because the type we are claiming to have initialized here is a
    // bunch of `MaybeUninit`s, which do not require initialization.
    let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };
    // 初始化了500个String变量
    let mut data_len: usize = 0;
    for elem in &mut data[0..500] {
        //write没有将所有权转移出ManuallyDrop
        elem.write(String::from("hello"));
        data_len += 1;
    }
    // For each item in the array, drop if we allocated it.
    //rust不能自动去释放已经申请的String, 必须手工调用drop_in_place释放
    for elem in &mut data[0..data_len] {
        unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }
    }
```
上例中，在没有assume_init()调用的情况下，必须手工调用drop_in_place释放内存。
MaybeUninit<T>是一个非常重要的类型结构，未初始化内存是编程中不可避免要遇到的情况，MaybeUninit<T>也就是RUST编程中必须熟练使用的一个类型。

### mem模块函数库
`mem::zeroed<T>() -> T` 代码如下：
```rust
pub unsafe fn zeroed<T>() -> T {
    // 调用者必须确认T类型的变量可以取全零值
    unsafe {
        intrinsics::assert_zero_valid::<T>();
        MaybeUninit::zeroed().assume_init()
    }
}
```
`mem::uninitialized<T>() -> T` 用MaybeUnint::uninit获取一块未初始化内存，然后调用assume_init(), 此时内存彻底未初始化。
```rust
pub unsafe fn uninitialized<T>() -> T {
    // 调用者必须确认T类型的变量允许未初始化的任意值
    unsafe {
        intrinsics::assert_uninit_valid::<T>();
        MaybeUninit::uninit().assume_init()
    }
}
```
`mem::take<T: Default>(dest: &mut T) -> T` 将dest设置为默认内容(不改变所有权)，用一个新变量返回dest的内容。
```rust
pub fn take<T: Default>(dest: &mut T) -> T {
    //即mem::replace，见下文
    replace(dest, T::default())
}
```
`mem::replace<T>(dest: &mut T, src: T) -> T` 用src的内容赋值dest(不改变所有权)，用一个新变量返回dest的内容。 
```rust
pub const fn replace<T>(dest: &mut T, src: T) -> T {
    unsafe {
        //这个赋值实际上导致*dest的所有权转移到了T，dest的所有权必须有处理
        let result = ptr::read(dest);
        //ptr::write本身会导致src的所有权转移到dest，然后src被forget，这就处理了read()遗留的所有权问题
        ptr::write(dest, src);
        result
    }
}
```

`mem::transmute_copy<T, U>(src: &T) -> U` 新建类型U的变量，并把src的内容拷贝到U。调用者应保证T类型的内容与U一致
```rust
pub const unsafe fn transmute_copy<T, U>(src: &T) -> U {
    if align_of::<U>() > align_of::<T>() {
        // 如果两个类型字节对齐U 大于 T. 使用read_unaligned
        unsafe { ptr::read_unaligned(src as *const T as *const U) }
    } else {
        //用read即可完成
        unsafe { ptr::read(src as *const T as *const U) }
    }
}
```
`mem::forget<T>(t:T)` 通知RUST不做变量的drop操作  
```rust
pub const fn forget<T>(t: T) {
    //没有使用intrinsic::forget, 实际上效果一致，这里应该是尽量规避用intrinsic函数
    let _ = ManuallyDrop::new(t);
}
```
`mem::forget_unsized<T:Sized?>` 对intrinsics::forget的封装 
`mem::size_of<T>()->usize`/`mem::min_align_of<T>()->usize`/`mem::size_of_val<T>(val:& T)->usize`/`mem::min_align_of_val<T>(val: &T)->usize`/`mem::needs_drop<T>()->bool` 基本就是直接调用intrinsic模块的同名函数  
`mem::drop<T>(_x:T)` 释放内存  

### ptr模块再探
`ptr::read<T>(src: *const T) -> T` 此函数用已有的类型复制出一个新的类型实体,对于不支持Copy Trait的类型，read函数是RUST实现未知类型变量的复制的一种方法，此函数作为内存函数take(), replace(), transmute_copy()的基础，底层使用intrisic::copy_no_overlapping支持,代码已经在`MaybeUninit::assume_init_read`那里已经分析过  

`ptr::read_unaligned<T>(src: *const T) -> T`当数据结构中有未内存对齐的成员变量时，需要用此函数读取内容并转化为内存对齐的变量。否则会引发UB(undefined behaiver) 如下例： 

/// 从字节数组中读一个usize的值:
 ```rust
    use std::mem;
   
    fn read_usize(x: &[u8]) -> usize {
        assert!(x.len() >= mem::size_of::<usize>());
       
        let ptr = x.as_ptr() as *const usize;
        //此处必须用ptr::read_unaligned，因为不确定字节是否对齐
        unsafe { ptr.read_unaligned() }
    }
```
例子中，为了从byte串中读取一个usize，需要用read_unaligned来获取值，不能象C语言那样通过指针类型转换直接获取值。

`ptr::write<T>(dst: *mut T, src: T)` 代码如下：
```rust
pub const unsafe fn write<T>(dst: *mut T, src: T) {
    unsafe {
        //浅拷贝
        copy_nonoverlapping(&src as *const T, dst, 1);
        //必须调用forget，这里所有权已经转移。不允许再对src做drop操作
        intrinsics::forget(src);
    }
}
```
write函数本质上就是一个所有权转移的操作。完成src到dst的浅拷贝，然后调用了forget(src), 这使得src的Drop不再被调用（也规避src类型如果有引用导致的重复释放问题）。从而将所有权转移到dst。此函数是mem::replace， mem::transmute_copy的基础。底层由intrisic:: copy_no_overlapping支持。 
这个函数中，如果dst已经初始化过，那原dst变量的所有权将被丢失掉，有可能引发内存泄漏。 

`ptr::write_unaligned<T>(dst: *mut T, src: T)` 与read_unaligned相对应。举例如下：
```rust
    #[repr(packed, C)]
    struct Packed {
        _padding: u8,
        unaligned: u32,
    }
    
    let mut packed: Packed = unsafe { std::mem::zeroed() };
    
    // Take the address of a 32-bit integer which is not aligned.
    // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.
    // 对于结构中字节没有按照2幂次对齐的成员，要用addr_of_mut!宏来获得地址，无法用取引用的方式。
    let unaligned = std::ptr::addr_of_mut!(packed.unaligned);
    
    unsafe { std::ptr::write_unaligned(unaligned, 42) };
    
     assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.
```
`ptr::read_volatile<T>(src: *const T) -> T`  是intrinsics::volatile_load的封装  
`ptr::write_volatile<T>(dst: *mut T, src:T)` 是intrinsics::volatiel_store的封装  

`ptr::macro addr_of($place:expr)` 因为用&获得引用必须是字节按照2的幂次对齐的地址，所以用这个宏获取非地址对齐的变量地址  
```rust
pub macro addr_of($place:expr) {
    //关键字是&raw const，这个是RUST的原始引用语义，但目前还没有在官方做公开。
    //区别与&, &要求地址必须满足字节对齐和初始化，&raw 则没有这个问题
    &raw const $place
}
```
`ptr::macro addr_of_mut($place:expr)` 作用同上。  
```rust
pub macro addr_of_mut($place:expr) {
    &raw mut $place
}
```
指针的通用函数请参考[Rust库函数参考](https://doc.rust-lang.org/core/ptr/index.html#functions)


#### NonNull 与MaybeUninit<T>相关函数
```NonNull<T>::as_uninit_ref<`a>(&self) -> &`a MaybeUninit<T>``` NonNull与MaybeUninit的引用基本就是直接转换的关系，一体双面 
```rust
    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {
        // self.cast将NonNull<T>转换为NonNull<MaybeUninit<T>>
        //self.cast.as_ptr将NonNull<MaybeUninit<T>>转换为 *mut MaybeUninit<T>
        unsafe { &*self.cast().as_ptr() }
    }
``` 
```NonNull<T>::as_uninit_mut<`a>(&self) -> &`a mut MaybeUninit<T>```  
```NonNull<[T]>::as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>]```  
```rust
    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {
        // 下面的函数调用ptr::slice_from_raw_parts
        unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }
    }
```
```NonNull<[T]>::as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>]```   

#### Unique
Unique类型结构定义如下
```rust
    #[repr(transparent)]
    pub struct Unique<T: ?Sized> {
        pointer: *const T,
        // NOTE: this marker has no consequences for variance, but is necessary
        // for dropck to understand that we logically own a `T`.
        //
        // For details, see:
        // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
        _marker: PhantomData<T>,
    }
```
和NonNull对比，Unique多了PhantomData<T>类型变量。这个定义使得编译器知晓，Unique<T>拥有了pointer指向的内存的所有权，NonNull<T>没有这个特性。具备所有权后，Unique<T>可以实现Send, Sync等Trait。因为获得了所有权，此块内存无法用于他处，这也是Unique的名字由来原因.
指针在被Unique封装前，必须保证是NonNull的
RUST用Allocator申请出来的内存的所有权用Unique<T>做了绑定，使得内存进入了RUST的所有权和借用系统。

Unique模块的函数及代码与NonNull函数代码相类似，此处不分析。
`Unique::cast<U>(self)->Unique<U>` 类型转换，程序员应该保证T和U的内存布局相同  
`Unique::<T>::new(* mut T)->Option<Self>` 此函数内部判断* mut T是否为0值  
`Unique::<T>::new_unchecked(* mut T)->Self` 封装* mut T, 调用代码应该保证* mut T的安全性  
`Unique::as_ptr(self)->* mut T`  
`Unique::as_ref(&self)->& T` 因为Unique具备所有权，此处&T的生命周期与self相同，不必特别声明声明周期  
`Unique::as_mut(&mut self)->& mut T` 同上  

### RUST堆内存申请与释放接口
资深的C/C++程序员都了解，在大型系统开发时，往往需要自行实现内存管理模块，以根据系统的特点优化内存使用及性能，并作出内存跟踪。
对于操作系统，内存管理模块更是核心功能。
对于C/C++小型系统，没有内存管理，仅仅是调用操作系统的内存系统调用，内存管理交给操作系统负责。操作系统内存管理模块接口是内存申请及内存释放的系统调用
对于GC语言，内存管理由虚拟机或语言运行时负责，利用语言提供的new来完成类型结构内存获取。
RUST的内存管理分成了三个界面：
1. 由智能指针类型提供的类型创建函数，一般有new, 与其他的GC类语言相同，同时增加了一些更直观的函数。
2. 智能指针使用实现Allocator Trait的类型做内存申请及释放。Allocator使用编译器提供的函数名申请及释放内存。
3. 实现了GlobalAlloc Trait的类型来完成独立的内存管理模块，并用#[global_allocator]注册入编译器，替代编译器默认的内存申请及释放函数。
这样，RUST达到了：
1. 对于小规模的程序，拥有与GC语言相类似的内存获取机制
2. 对于大型程序和操作系统内核，从语言层面提供了独立的内存管理模块接口，达成了将现代语法与内存管理模块共同存在，相互配合的目的。
但因为所有权概念的存在，从内存申请到转换为类型系统仍然还存在复杂的工作。
堆内存申请和释放的Trait GlobalAlloc定义如下:
```rust
pub unsafe trait GlobalAlloc {
    //申请内存，因为Layout中内存大小不为0，所以，alloc不会申请大小为0的内存
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    //释放内存
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
    
    //申请后的内存应初始化为0
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        let ptr = unsafe { self.alloc(layout) };
        if !ptr.is_null() {
            // 此处必须使用write_bytes，确保每个字节都清零
            unsafe { ptr::write_bytes(ptr, 0, size) };
        }
        ptr
    }

    //其他方法
    ...
    ...
}
```
在内核编程或大的框架系统编程中，开发人员通常开发自定义的堆内存管理模块，模块实现GlobalAlloc Trait并添加#[global_allocator]标识。对于用户态，RUST标准库有默认的GlobalAlloc实现。
```rust
extern "Rust" {
    // 编译器会将实现了GlobalAlloc Trait，并标记 #[global_allocator]的四个方法自动转化为以下的函数
    #[rustc_allocator]
    #[rustc_allocator_nounwind]
    fn __rust_alloc(size: usize, align: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);
    #[rustc_allocator_nounwind]
    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;
}

//对__rust_xxxxx_再次封装
pub unsafe fn alloc(layout: Layout) -> *mut u8 {
    unsafe { __rust_alloc(layout.size(), layout.align()) }
}

pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }
}

pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
    unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }
}

pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {
    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }
}

```
再实现Allocator Trait，对以上四个函数做封装处理。作为RUST其他模块对堆内存的申请和释放接口。

```rust
pub unsafe trait Allocator {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        let ptr = self.allocate(layout)?;
        // SAFETY: `alloc` returns a valid memory block
        // 复杂的类型转换，实际是调用 *const u8::write_bytes(0, layout.size_)
        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }
        Ok(ptr)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);

    ...
}
```
Global 实现了 Allocator Trait。Rust大部分alloc库数据结构的实现使用Global作为Allocator。
```rust
unsafe impl Allocator for Global {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        //上文已经给出alloc_impl的说明
        self.alloc_impl(layout, false)
    }

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        self.alloc_impl(layout, true)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        if layout.size() != 0 {
            // SAFETY: `layout` is non-zero in size,
            // other conditions must be upheld by the caller
            unsafe { dealloc(ptr.as_ptr(), layout) }
        }
    }
    ...
    ...
}
```

Allocator使用GlobalAlloc接口获取内存，然后将GlobalAlloc申请到的* mut u8转换为确定大小的单一指针NonNull<[u8]>， 并处理申请内存可能出现的不成功。NonNull<[u8]>此时内存布局与 T的内存布局已经相同，后继可以转换为真正需要的T的指针并进一步转化为相关类型的引用，从而符合RUST类型系统安全并进行后继的处理。
以上是堆内存的申请和释放。 基于泛型，RUST也巧妙实现了栈内存的申请和释放机制 `mem::MaybeUninit<T>`

用Box的内存申请做综合举例：
```rust
    //此处A是一个A:Allocator类型
    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {
        //实质是T类型的内存Layout
        let layout = Layout::new::<mem::MaybeUninit<T>>();
        //allocate(layout)?返回NonNull<[u8]>, NonNull<[u8]>::<MaybeUninit<T>>::cast()返回NonNull<MaybeUninit<T>>
        let ptr = alloc.allocate(layout)?.cast();
        //as_ptr 成为 *mut MaybeUninit<T>类型原生指针
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }
    
    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
        //使用Unique封装* mut T，并拥有了*mut T指向的变量的所有权
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
```
以上代码可以看到，NonNull<[u8]>可以直接通过cast 转换为NonNull<MaybeUninit<T>>, 这是另一种MaybeUninit<T>的生成方法，直接通过指针类型转换将未初始化的内存转换为MaybeUninit<T>。

### 所有权转移的底层实现
所有权的转移实际上是两步：1.栈上内存的浅拷贝；2：原先的变量置标志表示所有权已转移。置标志的变量如果没有重新绑定其他变量，则在生命周期结束的时候被drop。 引用及指针自身也是一个isize的值变量，也有所有权，也具备生命周期。 
#### 变量调用drop的时机
如下例子：
```rust
struct TestPtr {a: i32, b:i32}
impl Drop for TestPtr {
    fn drop(&mut self) {
        println!("{} {}", self.a, self.b);
    }
}
fn main() {
   let test = Box::new(TestPtr{a:1,b:2});
   let test1 = *test;
   let mut test2 = TestPtr{a:2, b:3};
   //此行代码会导致先释放test2拥有所有权的变量，然后再给test2赋值。代码后的输出会给出证据
   //将test1的所有权转移给test2，无疑代表着test2现有的所有权会在后继无法访问，因此drop被立即调用。
   test2 = test1;
   println!("{:?}", test2);
}
```
输出：
2 3
TestPtr { a: 1, b: 2 }
1 2

## 小结
在RUST标准库的ptr, mem，alloc模块提供了RUST内存的底层操作。内存的底层操作是其他RUST库模块的基础设施。不能理解内存的底层操作，就无法驾驭RUST完成较复杂的任务。
