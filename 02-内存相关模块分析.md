# RUST标准库内存相关模块实现探秘
理解RUST程序的最关键就是理解RUST内存相关的标准库代码。内存标准库代码很好的阐明了RUST的编程规则。
RUST内存相关主要包括：从内存角度看RUST类型，内存分配与释放，内存拷贝，置值，内存地址操作等。

## RUST类型系统的内存布局 
类型内存布局是指类型的内部变量在内存布局中，内存顺序，内存大小，内存字节对齐等内容。
对于GC机制的高级语言，类型内存布局一般是交由编译器决定的。程序员不需要关心。C/C++语言中类型只有固定的一种内存布局排序方式和固定的对齐方式，编译器不会对此进行优化，程序员可预测类型内存布局。
RUST则不同，因为泛型，闭包，编译器优化的关系，类型内存布局方式编译器会根据需要对内存布局做调整，对程序员来说类型的内存布局是不可预测的，而在内存操作中，类型内存布局的一些信息是必须要使用的，所以，RUST提供了`Layout`内存布局类型。此布局类型结构是类型内存操作的基础。
`Layout`的数据结构如下：
```rust
pub struct Layout {
    // size of the requested block of memory, measured in bytes.
    // 类型需占用的内存大小，用字节数目表示
    size_: usize,
    //  按照此字节数目进行类型内存对齐， NonZeroUsize见代码后面文字分析
    align_: NonZeroUsize,
}
```
*`NonZeroUsize`是一种非0值的usize, 这种类型主要应用于不可取0的值，本结构中， 字节对齐属性变量不能被置0，所以用`NonZeroUsize`来确保安全性。如果用usize类型，那代码中就可能会把0置给align_，导致bug产生。这是RUST的一个设计规则，所有的限制要在类型定义即显性化，从而使bug在编译中就被发现。*

每一个RUST的类型都有自身独特的内存布局Layout。一种类型的Layout可以用`intrinsic::<T>::size_of()`及`intrinsic::<T>::min_align_of()`获得的类型内存大小和对齐来获得。
RUST的内存布局更详细原理阐述请参考[RUST内存布局] (https://doc.rust-lang.org/nomicon/data.html)，

### `#[repr(transparent)]`内存布局模式
repr(transparent)用于仅包含一个成员变量的类型，该类型的内存布局与成员变量类型的内存布局完全一致。类型仅仅具备编译阶段的意义，在运行时，类型变量与其成员变量可以认为是一个相同变量，可以相互无障碍类型转换。使用repr(transparent)布局的类型基本是一种封装结构。

### `#[repr(packed)]`内存布局模式
强制类型成员变量以1字节对齐，此种结构在协议分析和结构化二进制数据文件中经常使用

### `#[repr(RUST)]`内存布局模式
默认的布局方式，采用此种布局，RUST编译器会根据情况来自行优化内存

### `#[repr(C)]`内存布局模式
采用C语言布局方式， 所有结构变量按照声明的顺序在内存排列。默认4字节对齐。


## RUST内存的类型与函数库体系

### intrinsic 固有函数库——内存部分
intrinsics函数由编译器内置实现，并提供给其他模块使用，对于固有函数，没必要去关注如何实现，重要的是了解其功能和如何使用，intrinsics内存函数一般不由库以外的代码直接调用，而是由mem模块和ptr模块封装后再提供给其他模块。
`intrinsics::drop_in_place<T:Sized?>(to_drop: * mut T)` 在编译器无法自动drop时， 手工调用此函数将内存释放  
`intrinsics::forget<T:Sized?> (_:T)`, 通知编译器不回收forget的变量内存  
`intrinsics::needs_drop<T>()->bool`, 判断T类型是否需要做drop操作，实现了Copy Trait的类型会返回false  
`intrinsics::transmute<T,U>(e:T)->U`, 对于内存布局相同的类型 T和U, 完成将类型T变量转换为类型U变量  
`intrinsics::offset<T>(dst: *const T, offset: usize)->* const T`, 相当于C的类型指针加减计算  
`intrinsics::copy<T>(src:*const T, dst: *mut T, count:usize)`, 内存拷贝， src和dst内存可重叠， 类似c语言中的memmove  
`intrinsics::copy_no_overlapping<T>(src:*const T, dst: * mut T, count:usize)`, 内存拷贝， src和dst内存不重叠  
`intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)` , C语言的memset的RUST实现  
`intrinsics::size_of<T>()->usize` 类型内存空间字节大小  
`intrinsics::min_align_of<T>()->usize` 返回类型对齐字节大小  
`intrinsics::size_of_val<T>(_:*const T)->usize`返回指针指向的变量内存空间字节大小    
`intrinsics::min_align_of_val<T>(_: * const T)->usize` 返回指针指向的变量对齐字节大小  
`intrinsics::volatile_xxxx` 通知编译器不做内存优化的操作函数,一般用于硬件访问  
`intrinsics::volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize)` 内存拷贝  
`intrinsics::volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize)` 功能类似C语言memmove  
`intrinsics::volatile_set_memory<T>(dst: *mut T, val: u8, count: usize)`  功能类似C语言memset  
`intrinsics::volatile_load<T>(src: *const T) -> T`读取内存或寄存器，字节对齐  
`intrinsics::volatile_store<T>(dst: *mut T, val: T)`内存或寄存器写入，字节对齐  
`intrinsics::unaligned_volatile_load<T>(src: *const T) -> T` 字节非对齐  
`intrinsics::unaligned_volatile_store<T>(dst: *mut T, val: T)`字节非对齐  
`intrinsics::raw_eq<T>(a: &T, b: &T) -> bool` 内存比较，类似C语言memcmp  
`pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize` 基于类型T内存布局的偏移量  
`pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否判断, 相等返回ture, 不等返回false  
`pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否不等，不等返回true，  

### ptr模块初探
ptr模块是RUST的对指针的实现模块。相比于C指针内存地址的简单，RUST指针实现机制复杂的多，以满足实现内存安全的类型系统需求，并兼顾内存使用效率和方便性。对内存的操作需要对ptr的若干概念先做一个理解，本节主要基于intrinsics模块的基础对ptr模块的一些类型结构及函数做出分析，为下节的内存类型和函数库做一个基础。 

#### ptr模块中原生指针具体实现
RUST的原生指针类型(`*const T/*mut T`)实质是个数据结构体，由两个部分组成，第一个部分是一个内存地址，第二个部分对这个内存地址的限制性描述-元数据
```rust
//从下面结构定义可以看到，*const T本质就是PtrComponents<T>
pub(crate) union PtrRepr<T: ?Sized> {
    pub(crate) const_ptr: *const T,
    pub(crate) mut_ptr: *mut T,
    pub(crate) components: PtrComponents<T>,
}

pub(crate) struct PtrComponents<T: ?Sized> {
    //只能用*const (), * const T编译器已经默认还带有元数据。
    pub(crate) data_address: *const (),
    //不同类型指针的元数据
    pub(crate) metadata: <T as Pointee>::Metadata,
}

//从下面Pointee的定义可以看到一个RUST的编程技巧，即Trait可以只用来实现对关联类型的指定，Pointee这一Trait即只用来指定Metadata的类型。
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}
//廋指针元数据是单元类型，即是空
pub trait Thin = Pointee<Metadata = ()>;
```
元数据的规则:
* 对于固定大小类型的指针（实现了 `Sized` Trait）, RUST定义为廋指针(thin pointer)，元数据大小为0，类型为(),这里要注意，RUST中数组也是固定大小的类型，运行中对数组下标合法性的检测，就是比较是否已经越过了数组的内存大小。
* 对于动态大小类型的指针(DST 类型)，RUST定义为胖指针(fat pointer 或 wide pointer), 元数据为：  
    * 对于结构类型，如果最后一个成员是动态大小类型(结构的其他成员不允许为动态大小类型)，则元数据为此动态大小类型  
    的元数据  
    * 对于`str`类型, 元数据是按字节计算的长度值，元数据类型是usize  
    * 对于切片类型，例如`[T]`类型，元数据是数组元素的数目值，元数据类型是usize   
    * 对于trait对象，例如 dyn SomeTrait， 元数据是 [DynMetadata<Self>][DynMetadata]（后面代码解释）
    （例如：DynMetadata<dyn SomeTrait>)
随着RUST的发展，有可能会根据需要引入新的元数据种类。

在标准库代码当中没有指针类型如何实现Pointee Trait的代码，推测编译器针对每个类型自动的实现了Pointee。
如下为rust编译器代码的一个摘录
```rust
    pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
        // FIXME: should this normalize?
        let tail = tcx.struct_tail_without_normalization(self);
        match tail.kind() {
            // Sized types
            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
            | ty::Uint(_)
            | ty::Int(_)
            | ty::Bool
            | ty::Float(_)
            | ty::FnDef(..)
            | ty::FnPtr(_)
            | ty::RawPtr(..)
            | ty::Char
            | ty::Ref(..)
            | ty::Generator(..)
            | ty::GeneratorWitness(..)
            | ty::Array(..)
            | ty::Closure(..)
            | ty::Never
            | ty::Error(_)
            | ty::Foreign(..)
            // If returned by `struct_tail_without_normalization` this is a unit struct
            // without any fields, or not a struct, and therefore is Sized.
            | ty::Adt(..)
            // If returned by `struct_tail_without_normalization` this is the empty tuple,
            // a.k.a. unit type, which is Sized
            // 如果是固定类型，元数据是单元类型 tcx.types.unit，即为空
            | ty::Tuple(..) => tcx.types.unit,

            //对于字符串和切片类型，元数据为长度tcx.types.usize，这个是元素长度
            ty::Str | ty::Slice(_) => tcx.types.usize,

            //对于dyn Trait类型， 元数据从具体的DynMetadata获取*
            ty::Dynamic(..) => {
                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
                tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])
            },
            
            //以下类型不应有元数据
            ty::Projection(_)
            | ty::Param(_)
            | ty::Opaque(..)
            | ty::Infer(ty::TyVar(_))
            | ty::Bound(..)
            | ty::Placeholder(..)
            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
                bug!("`ptr_metadata_ty` applied to unexpected type: {:?}", tail)
            }
        }
    }
```
以上代码中的中文注释比较清晰的说明了编译器对每一个类型（或类型指针）都实现了Pointee中元数据类型的获取。
对于Trait对象的元数据的具体结构定义见如下代码：
```rust
//dyn Trait的元数据结构
pub struct DynMetadata<Dyn: ?Sized> {
    //堆中的函数VTTable变量的指针
    vtable_ptr: &'static VTable,
    //标示结构对Dyn的所有权关系
    phantom: crate::marker::PhantomData<Dyn>,
}

struct VTable {
    drop_in_place: fn(*mut ()),
    size_of: usize,
    align_of: usize,
}
```
`PhantomData`的含义英文如下：
 Zero-sized type used to mark things that "act like" they own a `T`.
一个零占用的变量，使得结构拥有了一个T类型的变量。在RUST中，这一用法常常为了表示生命周期关系，以作为安全性的一个判断。

VTable 中包含4个成员，上面的结构体仅列出了前三个，即指向实现Trait的结构的drop_in_place函数的指针; 结构内存占用字节大小；结构内存对齐字节大小；VTable结构后面的内存为Trait的所有行为的指针数组。

#### ptr模块函数
`ptr::drop_in_place<T: ?Sized>(to_drop: *mut T)` 此函数是编译器实现的，用于不需要RUST自动drop时，由程序代码调用以释放内存  
`ptr::metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata `用来返回原生指针的元数据  
`ptr::null<T>() -> *const T` 返回0值的`*const T`，0值的`*const T`，因为RUST安全代码中指针不能为0，所以只能用这个函数获得0值的* const T，这个函数也是RUST安全性的一个体现。  
`ptr::null_mut<T>()->*mut T` 同上，只是返回的是`*mut T`  
`ptr::from_raw_parts<T: ?Sized>(data_address: *const (), metadata: <T as Pointee>::Metadata) -> *const T` 从内存地址和元数据生成原生指针   
`ptr::from_raw_parts_mut<T: ?Sized>(data_address: *mut (), metadata: <T as Pointee>::Metadata) -> *mut T` 功能同上，形成可变指针
RUST指针类型转换时，经常使用以上两个函数获得需要的指针类型。
`ptr::slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] `  
`ptr::slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T]` 由原生指针类型及切片长度获得原生切片类型指针  
ptr模块的函数大部分逻辑都比较简单。很多就是intrinsic 函数进行一下包装。 


由`* const T`生成`*const [T]`的函数代码如下：
```rust
pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {
    //data.cast()将*const T转换为 *const()
    from_raw_parts(data.cast(), len)
}

pub const fn from_raw_parts<T: ?Sized>(
    data_address: *const (),
    metadata: <T as Pointee>::Metadata,
) -> *const T {
    // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T
    // and PtrComponents<T> have the same memory layouts. Only std can make this
    // guarantee.
    //由以下这个操作可以确认 * const T实质是个结构体。
    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }
}
```

#### `*const T/*mut T/*const [T]/*mut [T]` 若干方法
`ptr::*const T::is_null(self)->bool` 
`ptr::*mut T::is_null(self)->bool此`函数判断原生指针的地址值是否为0
`ptr::*const T::cast<U>(self) -> *const U ` ，本质上就是一个`*const T as *const U`。
`ptr::*mut T::cast<U>(self)->*mut U` cast函数主要完成不同类型的原生指针的互相转换，这里需要程序员确保U与T的内存布局一致，并保证指针的**元数据**也一致。
`ptr::*const T::to_raw_parts(self) -> (*const (), <T as super::Pointee>::Metadata)` 
`ptr::*mut T::to_raw_parts(self)->(* const (), <T as super::Pointee>::Metadata)`  由原生指针获得地址及元数据
```ptr::*const T::as_ref<`a>(self) -> Option<&`a T>``` 将原生指针转换为引用，因为*const T可能为零，所有需要转换为Option<& `a T>类型，转换的安全性由程序员保证，尤其注意满足RUST对引用的安全要求。转换后，数据进入安全的RUST环境。
```ptr::*mut T::as_ref<`a>(self)->Option<&`a T>```  
```ptr::*mut T::as_mut<`a>(self)->Option<&`a mut T>```同上，但转化类型为 &mut T。
`ptr::*const T::offset(self, count:isize)->* const T` `*mut T::offset(self, count:isize)->* mut T` 实质是intrinsics::offset的封装
`ptr::*const [T]::len()->usize` 获取切片元素数量
`*const T`及`*mut T`的方法的逻辑基本也都比较简单，但涉及到较多的指针类型转换，有时需要细致分析，举例如下：
```rust
    //该方法给* mut T置一个新值    
    pub fn set_ptr_value(mut self, val: *const u8) -> Self {
        // 指针类型分析如下
        // self: * mut T
        // &mut self：&mut *mut T
        // &mut self as *mut *const T: *mut *mut T as *mut *const T
        // &mut self as *mut *const T as *mut *const u8: *mut *const T as * mut *const u8
        let thin = &mut self as *mut *const T as *mut *const u8;
        // 指针类型分析如下
        //*thin: *(*mut *const u8)即mut *const u8  
        unsafe { *thin = val };
        self
    }
```

#### RUST引用`&T`的安全要求
1. 引用的内存地址必须是内存2的幂次字节对齐的
2. 引用的内存内容必须是初始化过的
举例：
 ```rust
    #[repr(packed)]
    struct RefTest {a:u8, b:u16, c:u32}
    fn main() {
        let test = RefTest{a:1, b:2, c:3};
        //下面代码无法通过编译，因为test.b 内存字节位于奇数，无法用于借用
        let ref1 = &test.b
    }
 ```

##### NonNull
定义如下：
```rust
#[repr(transparent)]
pub struct NonNull<T: ?Sized> {
    pointer: *const T,
}
```
如前文，因为`NonNull<T>`是`repr(transparent)`内存布局模式，所以，`NonNull<T>`在内存中与`*const T`完全一致。可以直接转化为`* const T`。
这种用法是是RUST常用的封装类型的惯用法。因为* const T是没有所有权，借用，生命周期的， 因此不能被RUST编译器做drop操作。而用NonNull<T>封装后，即具备了所有权，借用，生命周期的概念。
另外，NonNull<T>确保指针是非零值。指针为0实际上代表指针异常，在RUST中，应该用Option::None标识。有了NonNull<T>后，即可以用Option<NonNull<T>>来处理指针为0的情况。

NonNull<T>的相关方法：
```NonNull::<T>::cast<U>(self)->NonNull<U>``` 指针类型转换，程序员应该保证T和U的内存布局相同  
```NonNull::<T>::new(* mut T)->Option<Self>``` 可以判断`* mut T`是否为0值，并返回`Option<NonNull<T>>`类型,   
```NonNull::<T>::new_unchecked(* mut T)->Self``` 封装`* mut T`，不检查`* mut T`是否为0，程序员应保证`* mu T`不为0  
```NonNull::<T>::from_raw_parts( data_address: NonNull<()>, metadata: <T as super::Pointee>::Metadata) -> NonNull<T> ```，实际上先调用`ptr::from_raw_parts`形成`* const T`的指针，然后再形成`NonNull<T>`。  
`NonNull::<T>::to_raw_parts(self) -> (NonNull<()>, <T as super::Pointee>::Metadata)` 上面函数的反操作  
`NonNull::<T>::as_ptr(self)->* mut T` 返回原生指针  
```NonNull::<T>::as_ref<`a>(&self)->&`a T ```  
```NonNull::<T>::as_mut<`a>(&mut self)->&`a mut T``` 从NonNull返回结构引用，此时程序员应保证符合引用安全的规则  
```NonNull::<[T]>::slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self``` 将单一类型指针转化为切片类型指针，实质是`ptr::slice_from_raw_parts`的一种包装。  
NonNull<T>的方法逻辑也都简单，这里不做更深入的分析,以上的方法举例如下：
以下的实例展示了 NonNull在动态内存申请中的使用：
```rust
    impl Global {
        fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
            match layout.size() {
                0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
                // SAFETY: `layout` is non-zero in size,
                size => unsafe {
                    //raw_ptr是 *const u8类型
                    let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
                    //NonNull::new处理了raw_ptr为零的情况,返回NonNull<u8>,此时内存长度还与T不匹配
                    let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                    //将NonNull<u8>转换为NonNull<[u8]>, NonNull<[u8]>已经是类型T的内存长度。后继可以直接转换为T类型的指针了。
                    Ok(NonNull::slice_from_raw_parts(ptr, size))
                },
            }
        }
        ....
    }
```

## 所有权转移的底层实现
所有权的转移实际上是两步：1.栈上内存的浅拷贝；2：原先的变量置标志表示所有权已转移。置标志的变量如果没有重新绑定其他变量，则在生命周期结束的时候被drop。 引用及指针自身也是一个isize的值变量，也有所有权，也具备生命周期。

### RUST堆内存申请与释放接口
对于堆内存的申请和释放，RUST与其他语言不同，其他语言都是简单而直接的，如 C++/Java的new/delete， C语言的malloc/free等。但RUST的内存申请和释放是复杂和曲折的。 
RUST语言库因为要兼容内核与用户空间程序，堆内存的申请和释放给出了能够兼容两者的方案，并额外增加了扩展性。
RUST的内存申请和释放的方案是定义内存申请和释放的`GlobalAlloc Trait`。编译器自身实现了基于`GlobalAlloc`的用户态内存管理模块作为默认模块。但也允许开发者实现自定义的内存管理模块，该模块需要实现`GlobalAlloc`，并做配置,即可使整个库的堆内存申请和释放基于开发者自定义的内存管理模块。自定义内存申请模块通常在内核开发，复杂的框架开发中使用。
堆内存申请和释放的Trait GlobalAlloc定义如下:
```rust
pub unsafe trait GlobalAlloc {
    //申请内存，因为Layout中内存大小不为0，所以，alloc不会申请大小为0的内存
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    //释放内存
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
    
    //申请后的内存应初始化为0
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        // SAFETY: the safety contract for `alloc` must be upheld by the caller.
        let ptr = unsafe { self.alloc(layout) };
        if !ptr.is_null() {
            // SAFETY: as allocation succeeded, the region from `ptr`
            // of size `size` is guaranteed to be valid for writes.
            unsafe { ptr::write_bytes(ptr, 0, size) };
        }
        ptr
    }
```
在内核编程或大的框架系统编程中，开发人员通常开发自定义的堆内存管理模块，模块实现GlobalAlloc Trait并添加#[global_allocator]标识。用户态的库，RUST有默认的GlobalAlloc实现。
从代码中可以看到，GlobalAlloc申请返回* mut u8原始指针。此原始指针还要经过Allocator Trait处理之后，才能够被接下来的RUST内存相关模块继续处理。
```rust
pub unsafe trait Allocator {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        let ptr = self.allocate(layout)?;
        // SAFETY: `alloc` returns a valid memory block
        // 复杂的转换，实际是调用 *const u8::write_bytes(0, layout.size_)
        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }
        Ok(ptr)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);

    ...
}
```
Global 实现了 Allocator Trait。Rust大部分core库，alloc库数据结构的实现使用Global作为Allocator。
```rust
unsafe impl Allocator for Global {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        //上文已经给出alloc_impl的说明
        self.alloc_impl(layout, false)
    }

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        self.alloc_impl(layout, true)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        if layout.size() != 0 {
            // SAFETY: `layout` is non-zero in size,
            // other conditions must be upheld by the caller
            unsafe { dealloc(ptr.as_ptr(), layout) }
        }
    }
    ...
    ...
}

pub unsafe fn alloc(layout: Layout) -> *mut u8 {
    unsafe { __rust_alloc(layout.size(), layout.align()) }
}

```
`__rust_alloc`实际上会转化为GlobalAlloc::alloc的调用。

Allocator使用GlobalAlloc接口获取内存，然后将GlobalAlloc申请到的* mut u8转换为确定大小的单一指针NonNull<[u8]>， 并处理申请内存可能出现的不成功。NonNull<[u8]>此时内存布局与 T的内存布局已经相同，后继可以转换为真正需要的T的指针并进一步转化为相关类型的引用，从而符合RUST类型系统安全并进行后继的处理。
以上是堆内存的申请和释放。 基于泛型，RUST也巧妙实现了栈内存的申请和释放机制 `mem::MaybeUninit<T>`

### mem模块结构及函数

#### MaybeUninit<T>

##### MaybeUninit<T>结构定义
源代码如下：
```rust
    #[repr(transparent)] 
    pub union MaybeUninit<T> {
        uninit: (),
        value: ManuallyDrop<T>,
    }
```
MaybeUninit的内存布局就是`ManuallyDrop<T>`的内存布局，从后文可以看到，`ManuallyDrop<T>`实际就是T的内存布局。所以MaybeUninit在内存中实质也就是T类型。
RUST的引用使用的内存块必须保证是内存对齐及赋以初始值，未初始化的内存块和清零的内存块都不能满足引用的条件。但堆内存申请后都是未初始化的，且在程序中某些情况下也需要先将内存设置为未初始化，尤其在处理泛型时。因此，RUST提供了MaybeUninit<T>容器来实现对未初始化变量的封装，从而在不引发编译错误完成相关操作.
MaybeUninit<T>利用ManuallyDrop<T>的方式对T的未初始化进行了一个标识。这对T也有一个保护，使得未初始化的变量免于被RUST自动调用drop所释放掉.

##### ManuallyDrop<T> 结构及行为
源代码如下：
```rust
#[repr(transparent)]
pub struct ManuallyDrop<T: ?Sized> {
    value: T,
}
```
一个变量被ManuallyDrop获取所有权后，RUST编译器将不再对其自动调用drop操作。需要代码显式的调用drop来释放置入ManuallyDrop的T类型变量。
ManuallyDrop主要使用场景：
1. 作为MaybeUninit的内部结构，对未初始化的内存做一个保护和标识。
2. 希望由代码显式释放变量时。

重点关注的一些行为：
`ManuallyDrop<T>::new（val:T) -> ManuallyDrop<T>`, 此函数返回ManuallyDrop变量拥有传入的T类型变量所有权，并将此块内存直接用ManuallyDrop封装, 对于val，编译器不再主动做drop操作。这里，T实际上应该是实现了Sized的类型  
`ManuallyDrop<T>::into_inner(slot: ManuallyDrop<T>)->T`, 将封装的T类型变量所有权转移出来，编译器会重新将返回的变量纳入drop管理体系。  
`ManuallyDrop<T>::take(slot: &mut ManuallyDrop<T>)->T`，实质是复制一个变量。 不影响原有的变量。  
`ManuallyDrop<T>::drop(slot: &mut ManuallyDrop<T>)`，手动drop掉内部变量。  
`ManuallyDrop<T>::deref(&self)-> & T`, 返回内部包装的变量的引用，返回的引用在使用中没有特殊性  
`ManuallyDrop<T>::deref_mut(&mut self)-> & mut T`

ManuallyDrop代码举例：
```rust
    use std::mem::ManuallyDrop;
    let mut x = ManuallyDrop::new(String::from("Hello World!"));
    x.truncate(5); // 可以对x进行操作
    assert_eq!(*x, "Hello");
    // 但对x的drop不会再发生
```

##### MaybeUninit<T> 行为
MaybeUninit<T>提供了在GlobalAlloc Trait之外的一种获取内存的方法， 实际上可类比为泛型 new()的一种实现方式,不过返回的不是指针，而是变量。MaybeUninit<T>获取的内存位于栈空间。
`MaybeUninit<T>::uninit()->MaybeUninit<T>`, 是MaybeUninit<T>栈上申请内存的行为，申请的内存打下是T类型的内存大小，该内存没有初始化。利用泛型和Union内存布局，RUST巧妙的实现了在栈上申请一块未初始化内存。此函数非常非常非常值得关注，是非常多场景下的代码解决方案。
`MaybeUninit<T>::new(val:T)->MaybeUninit<T>`, 内部用ManuallyDrop封装了val, 然后用MaybeUninit封装ManuallyDrop。因为如果T没有初始化过，调用这个函数会编译失败，所以此时内存实际上已经初始化过了。
`MaybeUninit<T>::zeroed()->MaybeUninit<T>`, 申请了T类型内存并清零。
```rust
    pub fn zeroed() -> MaybeUninit<T> {
        let mut u = MaybeUninit::<T>::uninit();
        // SAFETY: `u.as_mut_ptr()` points to allocated memory.
        unsafe {
            //必须使用write_bytes，否则无法给内存清0
            u.as_mut_ptr().write_bytes(0u8, 1);
        }
        u
    }
```
`MaybeUninit<T>::assume_init()->T`,代码如下：

```rust
    pub const unsafe fn assume_init(self) -> T {
        // SAFETY: the caller must guarantee that `self` is initialized.
        // This also means that `self` must be a `value` variant.
        unsafe {
            intrinsics::assert_inhabited::<T>();
            //把T的所有权返回，编译器会主动对T调用drop
            ManuallyDrop::into_inner(self.value)
        }
    }
```
`MaybeUninit<T>::assume_init_read()->T` 此函数最后会调用ptr::read()函数。代码如下：
```rust
    pub const unsafe fn read<T>(src: *const T) -> T {` 
        //利用MaybeUninit::uninit申请未初始化的T类型内存
        let mut tmp = MaybeUninit::<T>::uninit();
        //SAFETY: the caller must guarantee that `src` is valid for reads.
        // `src` cannot overlap `tmp` because `tmp` was just allocated on
        // the stack as a separate allocated object.
        //
        // Also, since we just wrote a valid value into `tmp`, it is guaranteed
        // to be properly initialized.
        unsafe {
            //完成内存拷贝
            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);
            //初始化后的内存移出ManuallyDrop 并返回
            tmp.assume_init()
        }
    }
```
可见，assume_init_read 行为实际上是从一个已有类型生成并复制一个新的变量。 
`MaybeUninit<T>::assume_init_drop()` 对内部变量进行drop操作  
`MaybeUninit<T>::assume_init_ref()->&T` 返回内部T类型变量的借用，调用者应保证内部T类型变量已经初始化  
`MaybeUninit<T>::assume_init_mut()->&mut T`返回内部T类型变量的可变借用，  
`MaybeUninit<T>::write(val)->&mut T`, 代码如下：  
```rust
    pub const fn write(&mut self, val: T) -> &mut T {
        //下面这个等式实际上隐含了 *self必须是未初始化的，否则的话，这里会丢失掉已初始化的变量所有权信息，造成内存泄漏。
        //对于wirte
        *self = MaybeUninit::new(val);
        // SAFETY: We just initialized this value.
        unsafe { self.assume_init_mut() }
    }
```
`MaybeUninit<T>::uninit_array<const LEN:usize>()->[Self; LEN]` 此处对LEN的使用方式需要注意，这是不常见的一个泛型写法,这个函数同样的申请了一块内存。代码：
```rust
    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {
        // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.
        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }
    }
```
这里要注意区别数组类型和数组元素的初始化。对于数组[MaybeUninit<T>;LEN]这一类型本身来说，初始化就是确定整体的内存大小，所以数组类型在声明后就已经完成了。所以此时assume_init()是正确的。这是一个理解上的盲点。 

`MaybeUninit<T>::array_assume_init<const N:usize>(array: [Self; N]) -> [T; N]` 这个函数没有把所有权转移出来，代码分析如下：
```rust
    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {
        // SAFETY:
        // * The caller guarantees that all elements of the array are initialized
        // * `MaybeUninit<T>` and T are guaranteed to have the same layout
        // * `MaybeUninit` does not drop, so there are no double-frees
        // And thus the conversion is safe
        unsafe {
            //最后是调用是*const T::read()，此处 as *const _的写法可以简化代码,这里没有把T类型变量所有权转移到返回值
            (&array as *const _ as *const [T; N]).read()
        }
    }
```
MaybeUninit<T>一些典型使用代码例子：
Box的内存申请例子：
```rust
    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {
        let layout = Layout::new::<mem::MaybeUninit<T>>();
        //allocate(layout)?返回NonNull<[u8]>, NonNull<[u8]>::<MaybeUninit<T>>::cast()返回NonNull<MaybeUninit<T>>
        let ptr = alloc.allocate(layout)?.cast();
        //以下代码在Box结构时分析
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }
```
以上代码可以看到，NonNull<[u8]>可以直接通过cast 转换为NonNull<MaybeUninit<T>>, 这是另一种MaybeUninit<T>的生成方法，直接通过指针类型转换将未初始化的内存转换为MaybeUninit<T>。

```rust
    use std::mem::MaybeUninit;

    // Create an explicitly uninitialized reference. The compiler knows that data inside
    // a `MaybeUninit<T>` may be invalid, and hence this is not UB:
    // 获得一个未初始化的i32引用类型内存
    let mut x = MaybeUninit::<&i32>::uninit();
    // Set it to a valid value.
    // 将&0写入变量，完成初始化
    x.write(&0);
    // Extract the initialized data -- this is only allowed *after* properly
    // initializing `x`!
    // 将初始化后的变量解封装供后继的代码使用。
    let x = unsafe { x.assume_init() };
```
以上代码，编译器不会对x.write进行报警，这是MaybeUninit<T>的最重要的应用，这个例子展示了RUST如何给未初始化内存赋值的处理方式。调用assume_init前，必须保证变量已经被正确初始化。

更复杂的例子：
```rust
    use std::mem::{self, MaybeUninit};
    
    let data = {
    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is
    // safe because the type we are claiming to have initialized here is a
    // bunch of `MaybeUninit`s, which do not require initialization.
    // data在声明后实际上就已经初始化完毕。
    let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {
        //这里注意实际调用是MaybeUninit::<[MaybeUninit<Vec<u32>>;1000]>::uninit(), RUST的类型推断机制完成了泛型实例化
        MaybeUninit::uninit().assume_init()
    };
    
    // Dropping a `MaybeUninit` does nothing. Thus using raw pointer
    // assignment instead of `ptr::write` does not cause the old
    // uninitialized value to be dropped. Also if there is a panic during
    // this loop, we have a memory leak, but there is no memory safety
    // issue.
    for elem in &mut data[..] {
    elem.write(vec![42]);
    }
    
    // Everything is initialized. Transmute the array to the
    // initialized type.
    // 直接用transmute完成整个数组类型的转换
    unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }
    };
    
    assert_eq!(&data[0], &[42]);
```
下面例子说明一块内存被 MaybeUnint<T>封装后，编译器将不再对其做释放，必须在代码中显式释放：
```rust
    use std::mem::MaybeUninit;
    use std::ptr;
   
    // Create an uninitialized array of `MaybeUninit`. The `assume_init` is
    // safe because the type we are claiming to have initialized here is a
    // bunch of `MaybeUninit`s, which do not require initialization.
    let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };
    // 初始化了500个String变量
    let mut data_len: usize = 0;
    for elem in &mut data[0..500] {
        //write没有将所有权转移出ManuallyDrop
        elem.write(String::from("hello"));
        data_len += 1;
    }
    // For each item in the array, drop if we allocated it.
    //rust不能自动去释放已经申请的String, 必须手工调用drop_in_place释放
    for elem in &mut data[0..data_len] {
        unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }
    }
```
上例中，在没有assume_init()调用的情况下，必须手工调用drop_in_place释放内存。
MaybeUninit<T>是一个非常重要的类型结构，未初始化内存是编程中不可避免要遇到的情况，MaybeUninit<T>也就是RUST编程中必须熟练使用的一个类型。

### mem模块函数库：
`mem::zeroed<T>() -> T` 此函数用MaybeUninit::zeroed获取全零内存后，调用assume_init(), 返回一个清零的T变量，要确认全零是一种T类型合理的初始化才可用  
`mem::uninitialized<T>() -> T` 用MaybeUnint::uninit获取一块未初始化内存，然后调用assume_init(), 此时内存彻底未初始化。  
`mem::take<T: Default>(dest: &mut T) -> T` 将dest设置为默认内容(不改变所有权)，用一个新变量返回dest的内容。    
`mem::replace<T>(dest: &mut T, src: T) -> T` 用src的内容赋值dest(不改变所有权)，用一个新变量返回dest的内容。  
`mem::transmute<T,U>(src: T) -> U`  直接将T类型内存转化为U类型内存。 类似C语言的&(U *(&src))操作。  
`mem::transmute_copy<T, U>(src: &T) -> U` 新建类型U的变量，并把src的内容拷贝到U。  
`mem::forget<T>(t:T)` 通知RUST不做变量的drop操作，代码用ManuallyDrop完成  
`mem::forget_unsized<T:Sized?>` 代码用intrinsics::forget完成  
`mem::size_of<T>()->usize`/`mem::min_align_of<T>()->usize`/`mem::size_of_val<T>(val:& T)->usize`/`mem::min_align_of_val<T>(val: &T)->usize`/`mem::needs_drop<T>()->bool` 基本就是直接调用intrinsic模块的同名函数  
`mem::drop<T>(_x:T)` 释放内存  

### ptr模块再探
`ptr::read<T>(src: *const T) -> T` 此函数用已有的类型复制出一个新的类型实体,对于不支持Copy Trait的类型，read函数是RUST实现未知类型变量的复制的一种方法，此函数作为内存函数take(),  replace(), transmute_copy()的基础，底层使用intrisic::copy_no_overlapping支持,代码分析已经在前面章节完成  
`ptr::read_unaligned<T>(src: *const T) -> T`当数据结构中有未内存对齐的成员变量时，需要用此函数读取内容并转化为内存对齐的变量。否则会引发UB(undefined behaiver) 如下例：

/// Read a usize value from a byte buffer:
 ```rust
    use std::mem;
   
    fn read_usize(x: &[u8]) -> usize {
        assert!(x.len() >= mem::size_of::<usize>());

        let ptr = x.as_ptr() as *const usize;
        unsafe { ptr.read_unaligned() }
    }
```
例子中，为了从byte串中读取一个usize，需要用read_unaligned来获取值，不能象C语言那样通过指针类型转换直接获取值。

`ptr::write<T>(dst: *mut T, src: T)` write函数将src的内容拷贝到dst，同时调用了forget(src), 这使得src的Drop不再被调用。这里调用forget因为src可能包含智能指针或其他引用，forget仅仅对src的栈内存有影响，不影响可能的智能指针或其他引用的深层内存，这些深层的内存由dst继承。如果不做forget，后继src的drop操作就可能释放深层内存，导致dst的引用或指针成为悬垂指针。ptr::write是RUST实现内存拷贝的另一种方法。 此函数作为mem::replace， mem::transmute_copy的基础。底层由intrisic:: copy_no_overlapping支持

`ptr::write_unaligned<T>(dst: *mut T, src: T)` 与read_unaligned相对应。举例如下：  
```rust
    #[repr(packed, C)]
    struct Packed {
        _padding: u8,
        unaligned: u32,
    }
    
    let mut packed: Packed = unsafe { std::mem::zeroed() };
    
    // Take the address of a 32-bit integer which is not aligned.
    // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.
    // 对于结构中字节没有按照2幂次对齐的成员，要用addr_of_mut!宏来获得地址，无法用取引用的方式。
    let unaligned = std::ptr::addr_of_mut!(packed.unaligned);
    
    unsafe { std::ptr::write_unaligned(unaligned, 42) };
    
     assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.
```
`ptr::read_volatile<T>(src: *const T) -> T`  是intrinsics::volatile_load的封装  
`ptr::write_volatile<T>(dst: *mut T, src:T)` 是intrinsics::volatiel_store的封装  

`ptr::macro addr_of($place:expr)` 因为用&获得引用必须是字节按照2的幂次对齐的地址，所以用这个宏获取非地址对齐的变量地址
`ptr::macro addr_of_mut($place:expr)` 作用同上。
指针的通用函数请参考[Rust库函数参考](https://doc.rust-lang.org/core/ptr/index.html#functions)

#### NonNull 与MaybeUninit<T>相关函数
```NonNull<T>::as_uninit_ref<`a>(&self) -> &`a MaybeUninit<T>``` NonNull与MaybeUninit的引用基本就是直接转换的关系，一体双面
```NonNull<T>::as_uninit_mut<`a>(&self) -> &`a mut MaybeUninit<T>```
```NonNull<[T]>::as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>]```
```NonNull<[T]>::as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>]``` 

#### Unique
Unique类型结构定义如下
```rust
    #[repr(transparent)]
    pub struct Unique<T: ?Sized> {
        pointer: *const T,
        // NOTE: this marker has no consequences for variance, but is necessary
        // for dropck to understand that we logically own a `T`.
        //
        // For details, see:
        // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
        _marker: PhantomData<T>,
    }
```
和NonNull对比，Unique多了PhantomData<T>类型变量。这个定义使得编译器知晓，Unique<T>拥有了pointer指向的内存的所有权，NonNull<T>没有这个特性。具备所有权后，Unique<T>可以实现Send, Sync等Trait。
指针在被Unique封装前，必须保证是NonNull的
RUST用Allocator申请出来的内存的所有权用Unique<T>做了绑定，使得内存进入了RUST的所有权和借用系统。
Unique<T>创建举例：
```rust
    //下面的代码前文已经解释过，请参考
    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {
        let layout = Layout::new::<mem::MaybeUninit<T>>();
        let ptr = alloc.allocate(layout)?.cast();
        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }
    
    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
```
以上代码是Box<T>的创建关联函数，从代码可以分析比较完整的RUST的动态内存申请类型转换过程是，GlobalAlloc::alloc申请返回* mut u8指针，Allocator::allocate() 返回NonNull<[U8]>类型指针，由NonNull::cast()转化为NonNull<MaybeUninit<T>>类型，然后由NonNull<MaybeUninit<T>> 重新拆封装建立Unique<MaybeUninit<T>>类型。至此，申请的动态内存进入了RUST的所有权识别领域

`Unique::cast<U>(self)->Unique<U>` 类型转换，程序员应该保证T和U的内存布局相同  
`Unique::<T>::new(* mut T)->Option<Self>` 此函数内部判断* mut T是否为0值  
`Unique::<T>::new_unchecked(* mut T)->Self` 封装* mut T, 调用代码应该保证* mut T的安全性  
`Unique::as_ptr(self)->* mut T`  
`Unique::as_ref(&self)->& T` 因为Unique具备所有权，此处&T的生命周期与self相同，不必特别声明声明周期  
`Unique::as_mut(&mut self)->& mut T` 同上  

### 小结
在RUST标准库的ptr, mem，alloc模块提供了RUST内存的底层操作。内存的底层操作是其他RUST库模块的基础设施。不能理解内存的底层操作，就无法驾驭RUST完成较复杂的任务。
